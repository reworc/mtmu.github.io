<!DOCTYPE html>
<html lang="DE-de">
  <head>
    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v6.js"></script>
    <title>D3 Dev page</title>
  </head>
  <body>
    <h1>Statistiken</h1>
    <h2>Publikationen nach Jahr</h2>
    <div id="dataVis_numPubYear">
    </div>
    <h2>Co-Authoren</h2>
    <div class="visualization__authors">
    <div class="visualization__authors--buttons">
        <p>Sortierung</p>
        <fieldset>
          <input type="radio" id="d" name="sort" value="0" onchange="drawAuthors(url, this.value)">
          <label for="d">Datum (neuste zuerst)</label> 
          <input type="radio" id="h" name="sort" value="1" onchange="drawAuthors(url, this.value)" checked>
          <label for="h">Häufigkeit</label>
          <input type="radio" id="n" name="sort" value="2" onchange="drawAuthors(url, this.value)">
          <label for="n">Name</label> 
        </fieldset>
      </div>
      <div class="visualization__authors--diagram" id="dataVis_Authors">
      </div>
    </div>
    <h2>Co-Author Timline</h2>
    <div class="visualization__authors--diagram" id="dataVis_AuthorPeriod"></div>
    <h2>Keywords</h2>
    <div id="dataVis_Keywords"></div>
    <h2>Most-used keywords (Spider)</h2>
    <div id="dataVis_KeywordsSpider"></div>
    
    
    <script>
      Array.prototype.max = function() {
        return Math.max.apply(null, this);
      };

      Array.prototype.min = function() {
        return Math.min.apply(null, this);
      };

      const extractAuthors = (authorString) => 
      {
        const authorRegex = /([^,&]+)(, | & )?/g;

        var arr = authorString.split(/[/,|&]+/);
        return arr.map((s) => s.trim());
      };

      const arrayRange = (start, stop, step) => 
        Array.from(
          { length: (stop - start) / step + 1 },
          (value, index) => start + index * step
      );

      /// draw d3.js bar plot of publications
      const drawPublications = (url) => {  
        // set the dimensions and margins of the graph
        const margin = {top: 30, right: 30, bottom: 70, left: 60},
            width = 800 - margin.left - margin.right,
            height = 300 - margin.top - margin.bottom;
        
        // append the svg object to the body of the page
        const svg = d3.select("#dataVis_numPubYear")
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // Parse the Data
        d3.json(url).then( function(data) {
        
          const minYear = data.years.map(d => d.name).min();
          const maxYear = data.years.map(d => d.name).max();

          const arrayYears = arrayRange(minYear, maxYear, 1);

          // X axis
          const x = d3.scaleBand()
              .range([ 0, width ])
              .domain(arrayYears)
              .padding(0.6);
            svg.append("g")
              .attr("transform", `translate(0, ${height})`)
              .call(d3.axisBottom(x))
              .selectAll("text")
                .attr("transform", "translate(-10,0)rotate(-45)")
                .style("text-anchor", "end");

          const maxPublications = data.years.map((y) => y.elements.length).max();

          // Add Y axis
          let y = d3.scaleLinear()
            .domain([0, maxPublications])
            .range([ height, 0]);
          svg.append("g")
            .call(d3.axisLeft(y).ticks(maxPublications).tickFormat(d3.format("d"))
          );

          // Bars - start height with 0: correct height is set in animation
          svg.selectAll("mybar")
            .data(data.years)
            .join("rect")
              .attr("x", d => x(d.name))
              .attr("width", x.bandwidth())
              .attr("fill", barColor)
              .attr("height", function(d) { return height - y(0); }) // always equal to 0
              .attr("y", function(d) { return y(0); });

          // Animation
          svg.selectAll("rect")
            .transition()
            .duration(800)
            .attr("y", d => y(d.elements.length))
            .attr("height", d => height - y(d.elements.length))
            .delay((d,i) => i*100 );     
        });
      };

      /// draw horizontal d3 bar plot with number of publications per co-author
      /// can be sorted (@param order) by time (descending, 0), publication count (1) or name (2)
      const drawAuthors = (url, order) => {
        
        // set the dimensions and margins of the graph
        const margin = {top: 30, right: 30, bottom: 70, left: 200},
            width = 800 - margin.left - margin.right,
            height = 800 - margin.top - margin.bottom;
        d3.select("#dataVis_Authors").selectAll("*").remove();

        const svg = d3.select("#dataVis_Authors")
        .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Parse the Data
        d3.json(url).then( function(data) {

          var dict = new Map(); 

          data.years.forEach((y) => {
            y.elements.forEach((e) => { 

              var authors = extractAuthors(e.authors);
              authors.forEach((a) => {
                if (dict.has(a)) {
                  let num = dict.get(a);
                  dict.set(a, num + 1);
                } else {
                  dict.set(a, 1);
                }
              });
            });
          });

          // delete myself
          dict.delete("Mathias Müller");
          
          // if param is 1 or 2: sort map
          let sorted = dict; 
          if (Number(order) === 1) {
            sorted = new Map([...dict].sort((a,b) => b[1] - a[1]));
          } else if (Number(order) === 2 ) {
            sorted = new Map([...dict].sort((a,b) => a[0].localeCompare(b[0])));
          }

          // get the highest number of co-authored publications
          const maxNum = Array.from(sorted.values()).max(); 
          
          // X axis
          let x = d3.scaleLinear()
            .domain([0, maxNum])
            .range([ 0, width]);

          svg.append("g")
            .attr("transform", `translate(0, ${height})`)
            .call(d3.axisBottom(x).ticks(maxNum).tickFormat(d3.format("d")))
            .selectAll("text")
            .attr("transform", "translate(-10,0)rotate(-45)")
            .style("text-anchor", "end");

          // Y axis
          const y = d3.scaleBand()
                    .range([ 0, height ])
                    .domain(Array.from(sorted.keys()))
                    .padding(0.2);

          svg.append("g")
            .call(d3.axisLeft(y));

          // Bars
          svg.selectAll("mybar")
            .data(Array.from(sorted))
            .join("rect")
              .attr("x", d => 0)
              .attr("y", d => y(d[0]))
              .attr("height", y.bandwidth())
              .attr("width", d => 0)
              .attr("fill", barColor);
              
          // Animation
          svg.selectAll("rect")
            .transition()
            .duration(800)
            .attr("x", d => 0)
            .attr("width", d => x(d[1]))
            .delay((d,i) => i*50 );     
        });
      };

      // draw a special bar plot visualizing the time between fist and last publication with a co-author
      // bars start at the first year and end at te last year
      // bars have circle at the start and the end, so that co-authors who appear only once are visible
      const drawAuthorPeriod = (url) => {
        
        // set the dimensions and margins of the graph
        const margin = {top: 30, right: 30, bottom: 70, left: 200},
            width = 800 - margin.left - margin.right,
            height = 800 - margin.top - margin.bottom;

        const svg = d3.select("#dataVis_AuthorPeriod")
        .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Parse the Data
        d3.json(url).then( function(data) {

          var dict = new Map(); 

          data.years.forEach((y) => {
            y.elements.forEach((e) => { 

              var authors = extractAuthors(e.authors);
              authors.forEach((a) => {
                if (dict.has(a)) {
                  let entry = dict.get(a);
                  dict.set(a, {number: entry.number + 1, minYear: Number(y.name), maxYear: Number(entry.maxYear) });
                } else {
                  dict.set(a, { number: 1, minYear: Number(y.name), maxYear: Number(y.name)});
                }
              });
            });
          });

          dict.delete("Mathias Müller");
          const sorted = new Map([...dict].sort((a,b) => a[0].localeCompare(b[0])));
          const maxYear = Array.from(sorted.values()).map(v => v.maxYear).max(); 
          const minYear = Array.from(sorted.values()).map(v => v.minYear).min(); 
          
          // X axis: start half a year early so that teh circle does not overlap the y-axis
          let x = d3.scaleLinear()
            .domain([minYear - 0.5, maxYear])
            .range([0, width]);
          svg.append("g")
            .attr("transform", `translate(0, ${height})`)
            .call(d3.axisBottom(x).ticks(maxYear-minYear).tickFormat(d3.format("d")))
            .selectAll("text")
            .attr("transform", "translate(-10,0)rotate(-45)")
            .style("text-anchor", "end");

          // Y axis
          const y = d3.scaleBand()
                    .range([ 0, height ])
                    .domain(Array.from(sorted.keys()))
                    .padding(0.2);

          svg.append("g")
            .call(d3.axisLeft(y));

          // Bars
          svg.selectAll("mybar")
            .data(Array.from(sorted))
            .join("rect")
              .attr("x", d => x(d[1].minYear))
              .attr("y", d => y(d[0]))
              .attr("height", y.bandwidth())
              .attr("width", d => x(d[1].maxYear) - x(d[1].minYear))
              .attr("fill", barColor2);

          const circleRadius = 0.5 * y.bandwidth();

          // Circles of variable 1
          svg.selectAll("mycircle")
            .data(Array.from(sorted))
            .enter()
            .append("circle")
              .attr("cx", d => x(d[1].minYear))
              .attr("cy", d => y(d[0]) + circleRadius)
              .attr("r", `${circleRadius}`)
              .style("fill", circleColor)
              .style("stroke", circleOutline)
              .style("stroke-width", "2");

          // Circles of variable 2
          svg.selectAll("mycircle")
            .data(Array.from(sorted))
            .enter()
            .append("circle")
              .attr("cx", d => x(d[1].maxYear))
              .attr("cy", d => y(d[0])+ circleRadius)
              .attr("r", `${circleRadius}`)
              .style("fill", circleColor)
              .style("stroke", circleOutline)
              .style("stroke-width", "2");
          });
        };

      // horizontal bar plot visualizing how often specific key words were used
      // ordered by number of appearances
      const drawKeywords = (url, order) => {
        
        // set the dimensions and margins of the graph
        const margin = {top: 30, right: 30, bottom: 70, left: 200},
            width = 800 - margin.left - margin.right,
            height = 800 - margin.top - margin.bottom;
        d3.select("#dataVis_Keywords").selectAll("*").remove();

        const svg = d3.select("#dataVis_Keywords")
        .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Parse the Data
        d3.json(url).then( function(data) {

          var dict = new Map(); 

          data.years.forEach((y) => {
            y.elements.forEach((e) => { 

              var keywords = e.keywords;
              keywords.forEach((k) => {
                if (dict.has(k)) {
                  let num = dict.get(k);
                  dict.set(k, num + 1);
                } else {
                  dict.set(k, 1);
                }
              });
            });
          });

          let sorted = dict; 
          if (Number(order) === 1) {
            sorted = new Map([...dict].sort((a,b) => b[1] - a[1]));
          } else if (Number(order) === 2 ) {
            sorted = new Map([...dict].sort((a,b) => a[0].localeCompare(b[0])));
          }

          const maxNum = Array.from(sorted.values()).max(); 
            
          // X axis
          let x = d3.scaleLinear()
            .domain([0, maxNum])
            .range([ 0, width]);
          svg.append("g")
            .attr("transform", `translate(0, ${height})`)
            .call(d3.axisBottom(x).ticks(maxNum).tickFormat(d3.format("d")))
            .selectAll("text")
            .attr("transform", "translate(-10,0)rotate(-45)")
            .style("text-anchor", "end");

          // Y axis
          const y = d3.scaleBand()
                    .range([ 0, height ])
                    .domain(Array.from(sorted.keys()))
                    .padding(0.2);

          svg.append("g")
            .call(d3.axisLeft(y));

          // Bars
          svg.selectAll("mybar")
            .data(Array.from(sorted))
            .join("rect")
              .attr("x", d => 0)
              .attr("y", d => y(d[0]))
              .attr("height", y.bandwidth())
              .attr("width", d => 0)
              .attr("fill", barColor);

          // Animation
          svg.selectAll("rect")
            .transition()
            .duration(800)
            .attr("x", d => 0)
            .attr("width", d => x(d[1]))
            .delay((d,i) => i*20 );     
          });
        };

        const drawKeywordsSpider = (url) => {
          // set the dimensions and margins of the graph
          const margin = {top: 30, right: 30, bottom: 70, left: 30},
            width = 600 - margin.left - margin.right,
            height = 600 - margin.top - margin.bottom;

          const svg = d3.select("#dataVis_KeywordsSpider")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

          // Parse the Data
          d3.json(url).then( function(data) {

            var dict = new Map(); 

            data.years.forEach((y) => {
              y.elements.forEach((e) => { 

                var keywords = e.keywords;
                keywords.forEach((k) => {
                  if (dict.has(k)) {
                    let num = dict.get(k);
                    dict.set(k, num + 1);
                  } else {
                    dict.set(k, 1);
                  }
                });
              });
            });

            const sorted = new Map([...dict].sort((a,b) => b[1] - a[1]).slice(0,6));
            const maxNum = Array.from(sorted.values()).max();

            let radialScale = d3.scaleLinear()
              .domain([0, maxNum])
              .range([0, 250]);

            let ticks = [Math.floor(0.2 * maxNum), Math.floor(0.4 * maxNum), Math.floor(0.6 * maxNum), Math.floor(0.8 * maxNum), maxNum];
          
            svg.selectAll("circle")
              .data(ticks)
              .join(
                  enter => enter.append("circle")
                      .attr("cx", width / 2)
                      .attr("cy", height / 2)
                      .attr("fill", "none")
                      .attr("stroke", "gray")
                      .attr("r", d => radialScale(d))
            );

            svg.selectAll(".ticklabel")
            .data(ticks)
            .join(
                enter => enter.append("text")
                    .attr("class", "ticklabel")
                    .attr("x", width / 2 + 5)
                    .attr("y", d => height / 2 - radialScale(d))
                    .text(d => d.toString())
            );

            const angleToCoordinate = (angle, value) => {
              let x = Math.cos(angle) * radialScale(value);
              let y = Math.sin(angle) * radialScale(value);
              return {"x": width / 2 + x, "y": height / 2 - y};
            };

            const sortedArray = Array.from(sorted);

            let featureData = sortedArray.map((f, i) => {
              let angle = (Math.PI / 2) + (2 * Math.PI * i / sortedArray.length);
                return {
                    "name": f[0],
                    "angle": angle,
                    "line_coord": angleToCoordinate(angle, maxNum),
                    "label_coord": angleToCoordinate(angle, maxNum + 1)
                };
              });

            // draw axis line
            svg.selectAll("line")
              .data(featureData)
              .join(
                  enter => enter.append("line")
                      .attr("x1", width / 2)
                      .attr("y1", height / 2)
                      .attr("x2", d => d.line_coord.x)
                      .attr("y2", d => d.line_coord.y)
                      .attr("stroke","black")
              );

            // draw axis label
            svg.selectAll(".axislabel")
              .data(featureData)
              .join(
                  enter => enter.append("text")
                      .attr("x", d => d.label_coord.x)
                      .attr("y", d => d.label_coord.y)
                      .text(d => d.name)
              );
              
            let line = d3.line()
              .x(d => d.x)
              .y(d => d.y);

            const numKeyWords = sortedArray.map(i => i[1]);
            const labels = sortedArray.map(i => i[0]);

            const getPathCoordinates = (data_points) => {
              let coordinates = [];
              for (var i = 0; i < labels.length; i++){
                  let ft_name = labels[i];
                  let angle = (Math.PI / 2) + (2 * Math.PI * i / labels.length);
                  coordinates.push(angleToCoordinate(angle, data_points[i]));
              }
              return coordinates;
            };

            // draw the path element
            svg.selectAll("path")
                .data([numKeyWords])
                .join(
                    enter => enter.append("path")
                        .datum(d => getPathCoordinates(d))
                        .attr("d", line)
                        .attr("stroke-width", 4)
                        .attr("stroke", barColor)
                        .attr("fill", barColor)
                        .attr("stroke-opacity", 1)
                        .attr("opacity", 0.5)
                );

          });
        
        };

        const barColor = "#0084ba";
        const barColor2 = "#aaa"
        const circleColor = "#0084ba";
        const circleOutline = "#fff";

        const url = "https://reworc.github.io/mtmu.github.io/assets/data/publications.json";
        
        drawPublications(url);
        drawAuthors(url, 1);
        drawAuthorPeriod(url);
        drawKeywords(url, 1);
        drawKeywordsSpider(url);

      </script>
  </body>
</html>