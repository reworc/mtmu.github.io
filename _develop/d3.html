<!DOCTYPE html>
<html lang="DE-de">
  <head>
    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v6.js"></script>
    <title>D3 Dev page</title>
  </head>
  <body>
    <h1>Statistiken</h1>
    <h2>Publikationen nach Jahr</h2>
    <div id="dataVis_numPubYear"></div>
    <h2>Co-Authoren</h2>
    <div class="visualization__authors">
      <div class="visualization__authors--buttons">
        <p>Sortierung</p>
        <fieldset>
          <input
            type="radio"
            id="d"
            name="sort"
            value="0"
            onchange="drawAuthors(url, '#dataVis_Authors', this.value)"
          />
          <label for="d">Datum (neuste zuerst)</label>
          <input
            type="radio"
            id="h"
            name="sort"
            value="1"
            onchange="drawAuthors(url, '#dataVis_Authors', this.value)"
            checked
          />
          <label for="h">Häufigkeit</label>
          <input
            type="radio"
            id="n"
            name="sort"
            value="2"
            onchange="drawAuthors(url, '#dataVis_Authors', this.value)"
          />
          <label for="n">Name</label>
        </fieldset>
      </div>
      <div class="visualization__authors--diagram" id="dataVis_Authors"></div>
    </div>
    <h2>Co-Author Timline</h2>
    <div
      class="visualization__authors--diagram"
      id="dataVis_AuthorPeriod"
    ></div>
    <h2>Keywords</h2>
    <div id="dataVis_Keywords"></div>
    <h2>H&auml;ufigste Keywords</h2>
    <div id="dataVis_KeywordsSpider"></div>

    <div id="dataVis_KeywordsDonut"></div>
    <script>
      Array.prototype.max = function () {
        return Math.max.apply(null, this);
      };

      Array.prototype.min = function () {
        return Math.min.apply(null, this);
      };

      const extractAuthors = (authorString) => {
        const authorRegex = /([^,&]+)(, | & )?/g;

        var arr = authorString.split(/[/,|&]+/);
        return arr.map((s) => s.trim());
      };

      const arrayRange = (start, stop, step) =>
        Array.from(
          { length: (stop - start) / step + 1 },
          (value, index) => start + index * step
        );

      /// draw d3.js bar plot of publications
      const drawPublications = (url, elementId, names) => {
        // set the dimensions and margins of the graph
        const margin = { top: 50, right: 30, bottom: 30, left: 30 },
          width = 600 - margin.left - margin.right,
          height = 200 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        const svg = d3
          .select(elementId)
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Parse the Data
        d3.json(url).then(function (data) {
          const minYear = data.years.map((d) => d.name).min();
          const maxYear = data.years.map((d) => d.name).max();

          const arrayYears = arrayRange(minYear, maxYear, 1);

          var subgroups = data.years
            .map((y) => {
              const types = Array.from(y.elements.map((elem) => elem.type));
              return types;
            })
            .flat() // reduce array dimension
            .filter((value, index, array) => array.indexOf(value) === index) // remove duplicate values
            .sort((a, b) => a[0].localeCompare(b[0]));

          // color palette = one color per subgroup
          const color = d3
            .scaleOrdinal()
            .domain(subgroups)
            .range(publicationTypeColors);

          const publications_by_type = data.years.map((y) => {
            var typeMap = new Map();
            subgroups.forEach((g) => {
              typeMap.set(
                g,
                y.elements.reduce((total, elem) => total + (elem.type === g), 0)
              );
            });
            typeMap.set("year", Number(y.name));
            return Object.fromEntries(typeMap.entries());
          });

          //stack the data --> stack per subgroup
          const stackedData = d3.stack().keys(subgroups)(publications_by_type);

          // X axis
          const x = d3
            .scaleBand()
            .range([0, width])
            .domain(arrayYears)
            .padding(0.6);
          svg
            .append("g")
            .attr("transform", `translate(0, ${height})`)
            .call(d3.axisBottom(x))
            .selectAll("text")
            .attr("transform", "translate(-10,0)rotate(-45)")
            .style("text-anchor", "end");

          const maxPublications = data.years
            .map((y) => y.elements.length)
            .max();

          // Add Y axis
          let y = d3
            .scaleLinear()
            .domain([0, maxPublications])
            .range([height, 0]);
          svg
            .append("g")
            .call(
              d3.axisLeft(y).ticks(maxPublications).tickFormat(d3.format("d"))
            );

          // ----------------
          // Create a tooltip
          // ----------------
          var tooltip = d3.select(elementId).append("div").style("opacity", 0);

          // Three function that change the tooltip when user hover / move / leave a cell
          const mouseoverPubByType = function (event, d) {
            const subgroupName = d3.select(this.parentNode).datum().key;
            const subgroupValue = d.data[subgroupName];
            tooltip
              .html(
                "Typ: " +
                  publicationTypeNames.get(subgroupName) +
                  "<br>" +
                  "Anzahl: " +
                  subgroupValue
              )
              .style("opacity", 1)
              .attr("class", `d3-tooltip tooltip-${subgroupName}`);
          };
          const mousemovePubByType = function (event, d) {
            var rect = document
              .getElementById(elementId.replace("#", ""))
              .getBoundingClientRect();
            var x = event.clientX - rect.left; //x position within the element.
            var y = event.clientY - rect.top;
            tooltip.style("transform", `translate(${x}px, ${y}px`);
          };
          const mouseleavePubByType = function (event, d) {
            tooltip.style("opacity", 0);
          };

          // draw the bars
          svg
            .append("g")
            .selectAll("g")
            // Enter in the stack data = loop key per key = group per group
            .data(stackedData)
            .join("g")
            .attr("fill", (d) => color(d.key))
            .selectAll("rect")
            // enter a second time = loop subgroup per subgroup to add all rectangles
            .data((d) => d)
            .join("rect")
            .attr("x", (d) => x(d.data.year))
            .attr("y", (d) => y(0))
            .attr("height", (d) => height - y(0))
            .attr("width", x.bandwidth())
            .on("mouseover", mouseoverPubByType)
            .on("mousemove", mousemovePubByType)
            .on("mouseleave", mouseleavePubByType);

          // draw horizontal lines on the start of the block as border between groups
          svg
            .append("g")
            .selectAll("g")
            // Enter in the stack data = loop key per key = group per group
            .data(stackedData)
            .join("g")
            .attr("fill", (d) => color(d.key))
            .selectAll("line")
            // enter a second time = loop subgroup per subgroup to add all rectangles
            .data((d) => d)
            .join("line")
            .attr("x1", (d) => x(d.data.year))
            .attr("y1", (d) => y(d[0]))
            .attr("x2", (d) => x(d.data.year) + x.bandwidth())
            .attr("y2", (d) => y(d[0]))
            .attr("stroke", "#fff")
            .attr("stroke-width", (d) => (d[0] > 0 ? "2" : "0"));

          // Animation
          svg
            .selectAll("rect")
            .transition()
            .duration(400)
            .attr("y", (d) => y(d[1]))
            .attr("height", (d) => y(d[0]) - y(d[1]))
            .delay((d, i) => i * 10);
        });
      };

      /// draw horizontal d3 bar plot with number of publications per co-author
      /// can be sorted (@param order) by time (descending, 0), publication count (1) or name (2)
      const drawAuthors = (url, elementId, order) => {
        // set the dimensions and margins of the graph
        const margin = { top: 30, right: 30, bottom: 70, left: 150 },
          width = 600 - margin.left - margin.right,
          height = 600 - margin.top - margin.bottom;
        d3.select(elementId).selectAll("*").remove();

        const svg = d3
          .select(elementId)
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Parse the Data
        d3.json(url).then(function (data) {
          var dict = new Map();

          var subgroups = data.years
            .map((y) => {
              const types = Array.from(y.elements.map((elem) => elem.type));
              return types;
            })
            .flat() // reduce array dimension
            .filter((value, index, array) => array.indexOf(value) === index) // remove duplicate values
            .sort((a, b) => a[0].localeCompare(b[0]));

          // color palette = one color per subgroup
          const color = d3
            .scaleOrdinal()
            .domain(subgroups)
            .range(publicationTypeColors);

          data.years.forEach((y) => {
            y.elements.forEach((e) => {
              var authors = extractAuthors(e.authors);
              authors.forEach((a) => {
                if (dict.has(a)) {
                  let numbers_by_type = dict.get(a);
                  // author should contain a map with subgroups
                  const num = numbers_by_type.get(e.type);
                  numbers_by_type.set(e.type, num + 1);
                  dict.set(a, numbers_by_type);
                } else {
                  // initalize with empty map
                  let numbers_by_type = new Map();
                  subgroups.forEach((g) => numbers_by_type.set(g, 0));
                  numbers_by_type.set(e.type, 1);
                  dict.set(a, numbers_by_type);
                }
              });
            });
          });

          // delete myself
          dict.delete("Mathias Müller");

          // if param is 1 or 2: sort map
          let sorted = dict;

          if (Number(order) === 1) {
            sorted = new Map(
              [...dict].sort(
                (a, b) =>
                  Array.from(b[1].values()).reduce(
                    (partialSum, a) => partialSum + a,
                    0
                  ) -
                  Array.from(a[1].values()).reduce(
                    (partialSum, a) => partialSum + a,
                    0
                  )
              )
            );
          } else if (Number(order) === 2) {
            sorted = new Map(
              [...dict].sort((a, b) => a[0].localeCompare(b[0]))
            );
          }

          // get the highest number of co-authored publications
          const maxNum = [...dict].map(
            (a) =>
              Array.from(a[1].values()).reduce(
                (partialSum, a) => partialSum + a,
                0
              )
          ).max();          

          // X axis
          let x = d3.scaleLinear().domain([0, maxNum]).range([0, width]);

          svg
            .append("g")
            .attr("transform", `translate(0, ${height})`)
            .call(d3.axisBottom(x).ticks(maxNum).tickFormat(d3.format("d")))
            .selectAll("text")
            .attr("transform", "translate(-10,5)rotate(-45)")
            .style("text-anchor", "end");

          // Y axis
          const y = d3
            .scaleBand()
            .range([0, height])
            .domain(Array.from(sorted.keys()))
            .padding(0.2);

          svg
            .append("g")
            .call(d3.axisLeft(y))
            .selectAll("text")
            .attr("transform", "translate(-5,0)");

          //stack the data --> stack per subgroup
          const stackedData = d3.stack().keys(subgroups)(
            [...dict].map((elem) => {
              let result = Object.fromEntries(elem[1]);
              result.author = elem[0];
              return result;
            })
          );

          // draw the bars
          svg
            .append("g")
            .selectAll("g")
            // Enter in the stack data = loop key per key = group per group
            .data(stackedData)
            .join("g")
            .attr("fill", (d) => color(d.key))
            .selectAll("rect")
            // enter a second time = loop subgroup per subgroup to add all rectangles
            .data((d) => d)
            .join("rect")
            .attr("x", (d) => 0)
            .attr("y", (d) => y(d.data.author))
            .attr("height", y.bandwidth())
            .attr("width", (d) => 0);

          // draw horizontal lines on the start of the block as border between groups
          svg
            .append("g")
            .selectAll("g")
            // Enter in the stack data = loop key per key = group per group
            .data(stackedData)
            .join("g")
            .selectAll("line")
            // enter a second time = loop subgroup per subgroup to add all rectangles
            .data((d) => d)
            .join("line")
            .attr("x1", (d) => x(d[0]) + 1)
            .attr("y1", (d) => y(d.data.author))
            .attr("x2", (d) => x(d[0]) + 1)
            .attr("y2", (d) => y(d.data.author) + y.bandwidth())
            .attr("stroke", "#fff")
            .attr("stroke-width", (d) => (d[0] > 0 ? "2" : "0"));

          // Animation
          svg
            .selectAll("rect")
            .transition()
            .duration(400)
            .attr("x", (d) => x(d[0]) + 1)
            .attr("width", (d) => x(d[1]) - x(d[0]))
            .delay((d, i) => i * 10);
        });
      };

      const barColor = "#0084ba";
      const barColor_light = "#1cbefe";
      const barcolor_rgb = "0, 132, 184";
      const barColor2 = "#aaa";
      const circleColor = "#0084ba";
      const circleOutline = "#fff";

      const publicationTypeNames = new Map([
        ["conference", "Konferenzproceeding"],
        ["poster", "Poster/Demo"],
        ["journal", "Journal"],
        ["monography", "Monographie"],
      ]);
      const publicationTypeColors = [
        "#002838",
        "#006a95",
        "#4da9cf",
        "#cce6f1",
      ];

      // const keywordColors = [
      //   "#002838",  // blue-150
      //   "#003823",  // green-150
      //   "#381300",  // red-150
      //   "#006a95",  // blue-400
      //   "#00955d",  // green-400
      //   "#953400",  // red-400
      //   "#4da9cf",  // blue-650
      //   "#4dcf9e",  // green-650
      //   "#cf7a4d",  // red-650
      //   "#cce6f1",  // blue-900
      //   "#ccf1e3",  // green-900
      //   "#f1d9cc"   // red-900
      // ]

      // const keywordColors = [
      //   "#000d13",  // blue-50
      //   "#004a2e",  // green-200
      //   "#00354a",  // blue-200
      //   "#008251",  // green-350
      //   "#005c82",  // blue-350
      //   "#00ba74",  // green-500
      //   "#0084ba",  // blue-500
      //   "#4dcf9e",  // green-650,
      //   "#4da9cf",  // blue-650
      //   "#99e3c7",  // green-800
      //   "#99cee3",  // blue-800
      //   "#e6f8f1",  // green-950
      //   "#e6f3f8",  // blue-950
      //   "#00130c",  // green-50
      // ]

      const keywordColors = [
        "#000d13", // blue-50
        "#4da9cf", // blue-650
        "#00354a", // blue-200
        "#99cee3", // blue-800
        "#005c82", // blue-350
        "#e6f3f8", // blue-950
        "#0084ba", // blue-500
      ];

      const url =
        "https://reworc.github.io/mtmu.github.io/assets/data/publications.json";

      drawPublications(url, "#dataVis_numPubYear");
      drawAuthors(url, "#dataVis_Authors", 1);
      // drawAuthorPeriod(url, "#dataVis_AuthorPeriod");
      // drawKeywords(url, "#dataVis_Keywords", 1);
      // drawKeywordsSpider(url, "#dataVis_KeywordsSpider");
      // drawKeywordsDonut(url, "#dataVis_KeywordsDonut");
    </script>
  </body>
</html>
