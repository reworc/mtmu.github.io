<!DOCTYPE html>
<html lang="DE-de">
  <head>
    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v6.js"></script>
    <title>D3 Dev page</title>
  </head>
  <body>
    <h1>Statistiken</h1>
    <h2>Publikationen nach Jahr</h2>
    <div id="dataVis_numPubYear">
    </div>
    <h2>Co-Authoren</h2>
    <div class="visualization__authors">
    <div class="visualization__authors--buttons">
        <p>Sortierung</p>
        <fieldset>
          <input type="radio" id="d" name="sort" value="0" onchange="drawAuthors(url, this.value)">
          <label for="d">Datum (neuste zuerst)</label> 
          <input type="radio" id="h" name="sort" value="1" onchange="drawAuthors(url, this.value)" checked>
          <label for="h">Häufigkeit</label>
          <input type="radio" id="n" name="sort" value="2" onchange="drawAuthors(url, this.value)">
          <label for="n">Name</label> 
        </fieldset>
      </div>
      <div class="visualization__authors--diagram" id="dataVis_Authors">
      </div>
    </div>
    <h2>Co-Author Timline</h2>
    <div class="visualization__authors--diagram" id="dataVis_AuthorPeriod"></div>
    <h2>Keywords</h2>
    <div id="dataVis_Keywords"></div>
    <h2>H&auml;ufigste Keywords</h2>
    <div id="dataVis_KeywordsSpider"></div>
    
    <div id="dataVis_KeywordsDonut"></div>
    <script>
      Array.prototype.max = function() {
        return Math.max.apply(null, this);
      };

      Array.prototype.min = function() {
        return Math.min.apply(null, this);
      };

      const extractAuthors = (authorString) => 
      {
        const authorRegex = /([^,&]+)(, | & )?/g;

        var arr = authorString.split(/[/,|&]+/);
        return arr.map((s) => s.trim());
      };

      const arrayRange = (start, stop, step) => 
        Array.from(
          { length: (stop - start) / step + 1 },
          (value, index) => start + index * step
      );

      /// draw d3.js bar plot of publications
const drawPublications = (url, elementId, names) => {  
  // set the dimensions and margins of the graph
  const margin = {top: 50, right: 30, bottom: 30, left: 30},
      width = 600 - margin.left - margin.right,
      height = 200 - margin.top - margin.bottom;
  
  // append the svg object to the body of the page
  const svg = d3.select(elementId)
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);
  
  // Parse the Data
  d3.json(url).then( function(data) {
  
    const minYear = data.years.map(d => d.name).min();
    const maxYear = data.years.map(d => d.name).max();

    const arrayYears = arrayRange(minYear, maxYear, 1);

    var subgroups = data.years.map((y) => {
      const types = Array.from(y.elements.map(elem => elem.type));
      return(types)}
      )
      .flat()                     // reduce array dimension
      .filter((value, index, array) => array.indexOf(value) === index) // remove duplicate values
      .sort((a, b) => a[0].localeCompare(b[0]));

    // color palette = one color per subgroup
    const color = d3.scaleOrdinal()
      .domain(subgroups)
      .range(publicationTypeColors);

    const publications_by_type = data.years.map((y) => {
      var typeMap = new Map();
      subgroups.forEach((g) => {
        typeMap.set(g, y.elements.reduce((total,elem) => total+(elem.type === g), 0));
      });
      typeMap.set('year', Number(y.name));
      return Object.fromEntries(typeMap.entries());
    });

    //stack the data --> stack per subgroup
    const stackedData = d3.stack()
      .keys(subgroups)
      (publications_by_type);

    // X axis
    const x = d3.scaleBand()
        .range([ 0, width ])
        .domain(arrayYears)
        .padding(0.6);
      svg.append("g")
        .attr("transform", `translate(0, ${height})`)
        .call(d3.axisBottom(x))
        .selectAll("text")
          .attr("transform", "translate(-10,0)rotate(-45)")
          .style("text-anchor", "end");

    const maxPublications = data.years.map((y) => y.elements.length).max();

    // Add Y axis
    let y = d3.scaleLinear()
      .domain([0, maxPublications])
      .range([ height, 0]);
    svg.append("g")
      .call(d3.axisLeft(y).ticks(maxPublications).tickFormat(d3.format("d"))
    );

    // ----------------
    // Create a tooltip
    // ----------------
    var tooltip = d3.select(elementId)
      .append("div")
      .style("opacity", 0)
      .attr("class", "d3-tooltip");

    // Three function that change the tooltip when user hover / move / leave a cell
    const mouseoverPubByType = function(event, d) {
      const subgroupName = d3.select(this.parentNode).datum().key;
      const subgroupValue = d.data[subgroupName];
      tooltip
          .html("Typ: " + publicationTypeNames.get(subgroupName) + "<br>" + "Anzahl: " + subgroupValue)
          .style("opacity", 1)
          .attr("class", `d3-tooltip tooltip-${subgroupName}`)

    }
    const mousemovePubByType = function(event, d) {

      var rect = document.getElementById(elementId.replace('#', '')).getBoundingClientRect();
      var x = event.clientX - rect.left; //x position within the element.
      var y = event.clientY - rect.top;  
      tooltip.style("transform", `translate(${(x)}px, ${(y)}px`);
    }
    const mouseleavePubByType = function(event, d) {
      tooltip
        .style("opacity", 0)
    }

    // draw the bars
    svg.append("g")
    .selectAll("g")
    // Enter in the stack data = loop key per key = group per group
    .data(stackedData)
    .join("g")
      .attr("fill", d => color(d.key))
      .selectAll("rect")
      // enter a second time = loop subgroup per subgroup to add all rectangles
      .data(d => d)
      .join("rect")
        .attr("x", d => x(d.data.year))
        .attr("y", d => y(0))
        .attr("height", d => height - y(0))
        .attr("width",x.bandwidth())
      .on("mouseover", mouseoverPubByType)
      .on("mousemove", mousemovePubByType)
      .on("mouseleave", mouseleavePubByType);
      
  // draw horizontal lines on the start of the block as border between groups
  svg.append("g")
    .selectAll("g")
    // Enter in the stack data = loop key per key = group per group
    .data(stackedData)
    .join("g")
      .attr("fill", d => color(d.key))
      .selectAll("line")
      // enter a second time = loop subgroup per subgroup to add all rectangles
      .data(d => d)
      .join("line")
        .attr("x1", d=> x(d.data.year))
        .attr("y1", d => y(d[0]))
        .attr("x2", d => x(d.data.year) + x.bandwidth())
        .attr("y2", d => y(d[0]))
        .attr("stroke", '#fff')
        .attr("stroke-width", d => d[0] > 0 ? "2" : "0")

    // Animation
    svg.selectAll("rect")
      .transition()
      .duration(400)
      .attr("y", d => y(d[1]))
      .attr("height", d => y(d[0]) - y(d[1]))
      .delay((d,i) => i*10 );   
  });
};

      /// draw horizontal d3 bar plot with number of publications per co-author
      /// can be sorted (@param order) by time (descending, 0), publication count (1) or name (2)
      const drawAuthors = (url, elementId, order) => {
        
        // set the dimensions and margins of the graph
        const margin = {top: 30, right: 30, bottom: 70, left: 150},
            width = 600 - margin.left - margin.right,
            height = 600 - margin.top - margin.bottom;
        d3.select(elementId).selectAll("*").remove();

        const svg = d3.select(elementId)
        .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Parse the Data
        d3.json(url).then( function(data) {

          var dict = new Map(); 

          data.years.forEach((y) => {
            y.elements.forEach((e) => { 

              var authors = extractAuthors(e.authors);
              authors.forEach((a) => {
                if (dict.has(a)) {
                  let num = dict.get(a);
                  dict.set(a, num + 1);
                } else {
                  dict.set(a, 1);
                }
              });
            });
          });

          // delete myself
          dict.delete("Mathias Müller");
          
          // if param is 1 or 2: sort map
          let sorted = dict; 
          if (Number(order) === 1) {
            sorted = new Map([...dict].sort((a,b) => b[1] - a[1]));
          } else if (Number(order) === 2 ) {
            sorted = new Map([...dict].sort((a,b) => a[0].localeCompare(b[0])));
          }

          // get the highest number of co-authored publications
          const maxNum = Array.from(sorted.values()).max(); 
          
          // X axis
          let x = d3.scaleLinear()
            .domain([0, maxNum])
            .range([ 0, width]);

          svg.append("g")
            .attr("transform", `translate(0, ${height})`)
            .call(d3.axisBottom(x).ticks(maxNum).tickFormat(d3.format("d")))
            .selectAll("text")
            .attr("transform", "translate(-10,5)rotate(-45)")
            .style("text-anchor", "end");

          // Y axis
          const y = d3.scaleBand()
                    .range([ 0, height ])
                    .domain(Array.from(sorted.keys()))
                    .padding(0.2);

          svg.append("g")
            .call(d3.axisLeft(y))
            .selectAll("text")
            .attr("transform", "translate(-5,0)");

          // Bars
          svg.selectAll("mybar")
            .data(Array.from(sorted))
            .join("rect")
              .attr("x", d => 0)
              .attr("y", d => y(d[0]))
              .attr("height", y.bandwidth())
              .attr("width", d => 0)
              .attr("fill", barColor);
              
          // Animation
          svg.selectAll("rect")
            .transition()
            .duration(800)
            .attr("x", d => 0)
            .attr("width", d => x(d[1]))
            .delay((d,i) => i*50 );     
        });
      };

      // draw a special bar plot visualizing the time between fist and last publication with a co-author
      // bars start at the first year and end at te last year
      // bars have circle at the start and the end, so that co-authors who appear only once are visible
      const drawAuthorPeriod = (url, elementId) => {
        
        // set the dimensions and margins of the graph
        const margin = {top: 30, right: 30, bottom: 70, left: 150},
            width = 600 - margin.left - margin.right,
            height = 600 - margin.top - margin.bottom;

        const svg = d3.select(elementId)
        .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Parse the Data
        d3.json(url).then( function(data) {

          var dict = new Map(); 

          data.years.forEach((y) => {
            y.elements.forEach((e) => { 

              var authors = extractAuthors(e.authors);
              authors.forEach((a) => {
                if (dict.has(a)) {
                  let entry = dict.get(a);
                  dict.set(a, {number: entry.number + 1, minYear: Number(y.name), maxYear: Number(entry.maxYear) });
                } else {
                  dict.set(a, { number: 1, minYear: Number(y.name), maxYear: Number(y.name)});
                }
              });
            });
          });

          dict.delete("Mathias Müller");
          const sorted = new Map([...dict].sort((a,b) => a[0].localeCompare(b[0])));
          const maxYear = Array.from(sorted.values()).map(v => v.maxYear).max(); 
          const minYear = Array.from(sorted.values()).map(v => v.minYear).min(); 
          
          // X axis: start half a year early so that teh circle does not overlap the y-axis
          let x = d3.scaleLinear()
            .domain([minYear - 0.5, maxYear])
            .range([0, width]);
          svg.append("g")
            .attr("transform", `translate(0, ${height})`)
            .call(d3.axisBottom(x).ticks(maxYear-minYear).tickFormat(d3.format("d")))
            .selectAll("text")
            .attr("transform", "translate(-10,5)rotate(-45)")
            .style("text-anchor", "end");

          // Y axis
          const y = d3.scaleBand()
                    .range([ 0, height ])
                    .domain(Array.from(sorted.keys()))
                    .padding(0.2);

          svg.append("g")
            .call(d3.axisLeft(y))
            .selectAll("text")
            .attr("transform", "translate(-5,0)");

          // Bars
          svg.selectAll("mybar")
            .data(Array.from(sorted))
            .join("rect")
              .attr("x", d => x(d[1].minYear))
              .attr("y", d => y(d[0]))
              .attr("height", y.bandwidth())
              .attr("width", d => x(d[1].maxYear) - x(d[1].minYear))
              .attr("fill", barColor2);

          const circleRadius = 0.5 * y.bandwidth();

          // Circles of variable 1
          svg.selectAll("mycircle")
            .data(Array.from(sorted))
            .enter()
            .append("circle")
              .attr("cx", d => x(d[1].minYear))
              .attr("cy", d => y(d[0]) + circleRadius)
              .attr("r", `${circleRadius}`)
              .style("fill", circleColor)
              .style("stroke", circleOutline)
              .style("stroke-width", "2");

          // Circles of variable 2
          svg.selectAll("mycircle")
            .data(Array.from(sorted))
            .enter()
            .append("circle")
              .attr("cx", d => x(d[1].maxYear))
              .attr("cy", d => y(d[0])+ circleRadius)
              .attr("r", `${circleRadius}`)
              .style("fill", circleColor)
              .style("stroke", circleOutline)
              .style("stroke-width", "2");
          });
        };

      // horizontal bar plot visualizing how often specific key words were used
      // ordered by number of appearances
      const drawKeywords = (url, elementId, order) => {
        
        // set the dimensions and margins of the graph
        const margin = {top: 30, right: 30, bottom: 70, left: 200},
            width = 600 - margin.left - margin.right,
            height = 1000 - margin.top - margin.bottom;
        d3.select(elementId).selectAll("*").remove();

        const svg = d3.select(elementId)
        .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Parse the Data
        d3.json(url).then( function(data) {

          var dict = new Map(); 

          data.years.forEach((y) => {
            y.elements.forEach((e) => { 

              var keywords = e.keywords;
              keywords.forEach((k) => {
                if (dict.has(k)) {
                  let num = dict.get(k);
                  dict.set(k, num + 1);
                } else {
                  dict.set(k, 1);
                }
              });
            });
          });

          let sorted = dict; 
          if (Number(order) === 1) {
            sorted = new Map([...dict].sort((a,b) => b[1] - a[1]));
          } else if (Number(order) === 2 ) {
            sorted = new Map([...dict].sort((a,b) => a[0].localeCompare(b[0])));
          }

          const maxNum = Array.from(sorted.values()).max(); 
            
          // X axis
          let x = d3.scaleLinear()
            .domain([0, maxNum])
            .range([ 0, width]);
          svg.append("g")
            .attr("transform", `translate(0, ${height})`)
            .call(d3.axisBottom(x).ticks(maxNum).tickFormat(d3.format("d")))
            .selectAll("text")
            .attr("transform", "translate(-10,5)rotate(-45)")
            .style("text-anchor", "end");

          // Y axis
          const y = d3.scaleBand()
                    .range([ 0, height ])
                    .domain(Array.from(sorted.keys()))
                    .padding(0.2);

          svg.append("g")
            .call(d3.axisLeft(y))
            .selectAll("text")
            .attr("transform", "translate(-5,0)");

          // Bars
          svg.selectAll("mybar")
            .data(Array.from(sorted))
            .join("rect")
              .attr("x", d => 0)
              .attr("y", d => y(d[0]))
              .attr("height", y.bandwidth())
              .attr("width", d => 0)
              .attr("fill", barColor);

          // Animation
          svg.selectAll("rect")
            .transition()
            .duration(800)
            .attr("x", d => 0)
            .attr("width", d => x(d[1]))
            .delay((d,i) => i*20 );     
          });
        };

      const drawKeywordsSpider = (url, elementId) => {
        // set the dimensions and margins of the graph
        const margin = {top: 30, right: 30, bottom: 70, left: 30},
          width = 600 - margin.left - margin.right,
          height = 400 - margin.top - margin.bottom;

        const svg = d3.select(elementId)
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
        .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Parse the Data
        d3.json(url).then( function(data) {

          var dict = new Map(); 

          data.years.forEach((y) => {
            y.elements.forEach((e) => { 

              var keywords = e.keywords;
              keywords.forEach((k) => {
                if (dict.has(k)) {
                  let num = dict.get(k);
                  dict.set(k, num + 1);
                } else {
                  dict.set(k, 1);
                }
              });
            });
          });

          const sorted = new Map([...dict].sort((a,b) => b[1] - a[1]).slice(0,6));
          const maxNum = Array.from(sorted.values()).max();

          let radialScale = d3.scaleLinear()
            .domain([0, maxNum])
            .range([0, 150]);

          let ticks = [Math.floor(0.2 * maxNum), Math.floor(0.4 * maxNum), Math.floor(0.6 * maxNum), Math.floor(0.8 * maxNum), maxNum];
        
          svg.selectAll("circle")
            .data(ticks)
            .join(
                enter => enter.append("circle")
                    .attr("cx", width / 2)
                    .attr("cy", height / 2)
                    .attr("fill", "none")
                    .attr("stroke", "#999")
                    .attr("r", d => radialScale(d))
          );

          svg.selectAll(".ticklabel")
          .data(ticks)
          .join(
              enter => enter.append("text")
                  .attr("class", "ticklabel")
                  .attr("x", width / 2 + 5)
                  .attr("y", d => height / 2 - radialScale(d))
                  .text(d => d.toString())
          );

          const angleToCoordinate = (angle, value) => {
            let x = Math.cos(angle) * radialScale(value);
            let y = Math.sin(angle) * radialScale(value);
            return {"x": width / 2 + x, "y": height / 2 - y};
          };

          const sortedArray = Array.from(sorted);

          let featureData = sortedArray.map((f, i) => {
            let angle = (Math.PI / 2) + (2 * Math.PI * i / sortedArray.length);
              return {
                  "name": f[0],
                  "angle": angle,
                  "line_coord": angleToCoordinate(angle, maxNum + 1),
                  "label_coord": angleToCoordinate(angle, maxNum + 2)
              };
          });

          // draw axis line
          svg.selectAll("line")
            .data(featureData)
            .join(
                enter => enter.append("line")
                    .attr("x1", width / 2)
                    .attr("y1", height / 2)
                    .attr("x2", d => d.line_coord.x)
                    .attr("y2", d => d.line_coord.y)
                    .attr("stroke", barColor_light)
                    .attr("stroke-width", "2")
            );

          // draw axis label
          svg.selectAll(".axislabel")
            .data(featureData)
            .join(
                enter => enter.append("text")
                    .attr("x", d => d.label_coord.x)
                    .attr("y", d => d.label_coord.y)
                    .attr("class", "visualization__keywords--spider--axisLabel")
                    .attr("text-anchor", (d, i) => i < (featureData.length / 2) ? "end" : "start") 
                    .text(d => d.name)
            );
            
          let line = d3.line()
            .x(d => d.x)
            .y(d => d.y);

          const numKeyWords = sortedArray.map(i => i[1]);
          const labels = sortedArray.map(i => i[0]);

          const getPathCoordinates = (data_points) => {
            let coordinates = [];
            for (var i = 0; i < labels.length; i++){
                let angle = (Math.PI / 2) + (2 * Math.PI * i / labels.length);
                coordinates.push(angleToCoordinate(angle, data_points[i]));
            }
            // close path
            coordinates.push(angleToCoordinate((Math.PI / 2), data_points[0]));
            return coordinates;
          };

          // draw the path element
          svg.selectAll("path")
              .data([numKeyWords])
              .join(
                  enter => enter.append("path")
                      .datum(d => getPathCoordinates(d))
                      .attr("d", line)
                      .attr("stroke-width", 2)
                      .attr("stroke", `rgba(${barcolor_rgb}, 1.0)`)
                      .attr("fill", `rgba(${barcolor_rgb}, 0.5)`)
              );

          });
        };

      const drawKeywordsDonut = (url, elementId, order) => {
        const width = 800,
        height = 480,
        margin = 80;

        // The radius of the pieplot is half the width or half the height (smallest one). I subtract a bit of margin.
        const radius = Math.min(width, height) / 2 - margin

        const labelRadiusMultiplyer = 1.4

        // append the svg object to the div called 'my_dataviz'
        const svg = d3.select(elementId)
          .append("svg")
            .attr("width", width)
            .attr("height", height)
          .append("g")
            .attr("transform", `translate(${width/2},${height/2})`);

        // Parse the Data
        d3.json(url).then( function(data) {

          var dict = new Map(); 

          data.years.forEach((y) => {
            y.elements.forEach((e) => { 

              var keywords = e.keywords;
              keywords.forEach((k) => {
                if (dict.has(k)) {
                  let num = dict.get(k);
                  dict.set(k, num + 1);
                } else {
                  dict.set(k, 1);
                }
              });
            });
          });

          let others = {key: "sonstige", value: 0, keywords: []};

          dict.forEach((v, k) => {
            if (v < 4) {
              others.value = others.value + 1;
              others.keywords.push(k);
            }
          });


          others.keywords.forEach(k => {
            dict.delete(k);
          });

          const sorted = new Map([...dict].sort((a,b) => a[0].localeCompare(b[0])));
          const maxNum = Array.from(sorted.values()).max();

          // set the color scale
          const color = d3.scaleOrdinal()
            .domain(Array.from(sorted.keys()))
            .range(keywordColors);

          // Compute the position of each group on the pie:
          const pie = d3.pie()
            .sort(null) // Do not sort group by size
            .value(d => d[1])
          const data_ready = pie(Array.from(sorted));

          // The arc generator
          const arc = d3.arc()
            .innerRadius(radius * 0.5)         // This is the size of the donut hole
            .outerRadius(radius * 0.8)

          // Another arc that won't be drawn. Just for labels positioning
          const outerArc = d3.arc()
            .innerRadius(radius * labelRadiusMultiplyer)
            .outerRadius(radius * labelRadiusMultiplyer)

          // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.
          svg
            .selectAll('allSlices')
            .data(data_ready)
            .join('path')
            .attr('d', arc)
            .attr('fill', d => color(d.data[1]))
            .attr("stroke", "white")
            .style("stroke-width", "2px")
            .style("opacity", 0.7)

          // Add the polylines between chart and labels:
          svg
            .selectAll('allPolylines')
            .data(data_ready)
            .join('polyline')
              .attr("stroke", "black")
              .style("fill", "none")
              .attr("stroke-width", 1)
              .attr('points', function(d) {
                let posA = arc.centroid(d) // line insertion in the slice
                posA[0] *= 1.15;
                posA[1] *= 1.15;
                const posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
                const posC = outerArc.centroid(d); // Label position = almost the same as posB
                const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
                posC[0] = radius * (labelRadiusMultiplyer * 1.025) * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left
                return [posA, posB, posC]
              })

          // Add the polylines between chart and labels:
          svg
            .selectAll('allLabels')
            .data(data_ready)
            .join('text')
              .text(d => `${d.data[0]} [${d.data[1]}]`)
              .attr('transform', function(d) {
                  const pos = outerArc.centroid(d);
                  const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                  pos[0] = radius * (labelRadiusMultiplyer * 1.05) * (midangle < Math.PI ? 1 : -1);
                  return `translate(${pos})`;
              })
              .style('text-anchor', function(d) {
                  const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                  return (midangle < Math.PI ? 'start' : 'end')
              });

          // Add labels with the number count on th arc:
          svg
            .selectAll('allLabels')
            .data(data_ready)
            .join('text')
              .text(d => `${d.data[1]}`)
              .attr('transform', function(d) {
                  const pos = arc.centroid(d);
                  //const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
                  //pos[0] = radius * (labelRadiusMultiplyer * 1.05) * (midangle < Math.PI ? 1 : -1);
                  return `translate(${pos})`;
              })
              .style('text-anchor', 'middle')
              .style('dominant-baseline', 'central')
              .style('font-weight', '700')
              .style('fill', '#fff');
        });
      };
      
      const barColor = "#0084ba";
      const barColor_light = "#1cbefe";
      const barcolor_rgb = "0, 132, 184";
      const barColor2 = "#aaa"
      const circleColor = "#0084ba";
      const circleOutline = "#fff";
      
      const publicationTypeNames = new Map([
            [ "conference", "Konferenzproceeding"],
            [ "poster", "Poster/Demo"],
            [ "journal", "Journal"],
            [ "monography", "Monographie"]
          ]);
      const publicationTypeColors = ["#002838", "#006a95", "#4da9cf", "#cce6f1"];

      const keywordColors = [
        "#000d13",
        
        // "#001a25",
        // "#002838",
        "#004a2e",
        "#00354a",
        "#4a1a00",
        // "#00425d",
        // "#004f70",
        "#007046",
        "#005c82",
        "#822e00",
        // "#006a95",
        // "#0077a7",
        "#0084ba",
        "#00a768",
        "#ba4100",

        // "#1a90c1",
        // "#339dc8",
        "#339dc8",
        "#33c890",
        "#c86733"
      ]
      
      const url = "https://reworc.github.io/mtmu.github.io/assets/data/publications.json";
      
      drawPublications(url, "#dataVis_numPubYear");
      drawAuthors(url, "#dataVis_Authors", 1);
      drawAuthorPeriod(url, "#dataVis_AuthorPeriod");
      drawKeywords(url, "#dataVis_Keywords", 1);
      drawKeywordsSpider(url, "#dataVis_KeywordsSpider");
      drawKeywordsDonut(url, "#dataVis_KeywordsDonut");

    </script>
  </body>
</html>